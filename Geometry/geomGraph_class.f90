module geomGraph_class

  use numPrecision
  use genericProcedures, only : fatalError, numToChar, isIn, quickSort
  use dictionary_class,  only : dictionary
  use intMap_class,      only : intMap
  use uniFills_class,    only : uniFills

  implicit none
  private

  !!
  !! Information about a unique cell fill
  !!
  !! Public:
  !!   idx -> matIdx or -uniIdx of the filling of local cell (-ve entry indicates universe)
  !!   id  -> Unique ID if is material fill or uniRootID otherwise
  !!
  !! uniRootId is the location of the data for the given universe in array
  !!
  type, private :: location
    integer(shortInt) :: idx = 0
    integer(shortInt) :: id  = 0
  end type location

  !!
  !! Runtime representation of geometry nesting structure
  !!
  !! Is a directed acyclic graphs represented by 1D array. Each entry contains
  !! two numbers: idx which determines content (matIdx or -uniIdx); id which is
  !! a uniRootID (universe fill) or uniqueID (material fill).
  !!
  !! UniRootID is the location of the beginning of data for a given universe. Fill for different
  !! local cells has the location: uniRootID + localID - 1.
  !!
  !! Note that there is no checking for the validity of localIDs! If a number outside
  !! a valid localIDs for the universe is given, content will be read form different universe!
  !!
  !! Unique IDs are generated by enumeration of the graph sinks (local cells with material fill).
  !!
  !! Sample Input Dictionary:
  !!   graph1 {type shrunk;}
  !!   graph2 {type extended;}
  !!
  !!
  !! Two types are available:
  !!   'shrunk'   -> Each local (material) cell has the same uniqueID in all universe instances
  !!   'extended' -> Every local (material) cell has its own uniqueID in all universe instances
  !!
  !! Public Members:
  !!   array       -> Array with graph data
  !!   uniqueCells -> Number of uniqueCells in the structure
  !!   usedMats    -> Sorted list of matIdxs which are used in the geometry
  !!   uniSizes    -> Number of local cells in each universe (by uniIdx)
  !!   rootUniIdx  -> Index of the root universe
  !!
  !! Interface:
  !!   init -> Build from uniFills and dictionary definition
  !!   getFill -> Get filling information at location given by uniRootIr & localID
  !!   kill -> Return to uninitialised state
  !!
  type, public :: geomGraph
    type(location), dimension(:), allocatable    :: array
    integer(shortInt)                            :: uniqueCells = 0
    integer(shortInt), dimension(:), allocatable :: usedMats

    ! Copy some information about the universes
    integer(shortInt), dimension(:), allocatable :: uniSizes
    integer(shortInt)                            :: rootUniIdx = 0
  contains
    procedure :: init
    procedure :: getFill
    procedure :: kill
    procedure :: materialNesting

    ! Private procedures
    procedure, private :: buildShrunk
    procedure, private :: buildExtended
    procedure, private :: setUniqueIDs
    procedure, private :: materialNestingStep
  end type geomGraph

contains

  !!
  !! Initialise graph representation of the geometry structure
  !!
  !! Args:
  !!   fills [in] -> Universe fill information
  !!   dict [in]  -> Dictionary with settings
  !!
  !! Errors:
  !!   fatalError if type (unique generation strategy) is unknown
  !!
  !! Assumes that `fills` is valid:
  !!   * No cycles
  !!   * No invalid uni indexes in the structure
  !!
  subroutine init(self, fills, dict)
    class(geomGraph), intent(inout) :: self
    type(uniFills), intent(in)      :: fills
    class(dictionary), intent(in)   :: dict
    character(nameLen)              :: type
    integer(shortInt)               :: i, N
    character(100), parameter :: Here = 'init (geomGraph_class.f90)'

    ! Select specific build procedure
    call dict % get(type, 'type')

    select case(type)
      case ('shrunk')
        call self % buildShrunk(fills)

      case ('extended')
        call self % buildExtended(fills)

      case default
        print *, "AVAILABLE GEOMETRY GRAPH TYPES:"
        print *, 'shrunk'
        print *, 'extended'
        call fatalError(Here, 'Unknown geometry graph type (unique cell generation &
                              &strategy): '//trim(type))
    end select

    ! Load the information about the size of each universe
    N = size(fills % uni)
    allocate(self % uniSizes(N))
    do i = 1, N
      self % uniSizes(i) = size(fills % uni(i) % fill)
    end do
    self % rootUniIdx = fills % root

  end subroutine init

  !!
  !! Return fill information for a local cell in a universe
  !!
  !! Meaning of output variables depend on the sign of `idx`.
  !! If it is -ve fill is a nested universe with uniIdx = -idx and uniRootId = id
  !! If it is +ve fill is material cell with matIdx = idx and uniqueID = id
  !!
  !! Args:
  !!   idx [out] -> matIdx or -uniIdx of the content
  !!   id [out]  -> UniqueID or uniRootID
  !!   uniRootID [in] -> Location in array of the universe
  !!   localID [in] -> ID of the local cell in the universe
  !!
  !! Errors:
  !!   If localID is too large or too small, content from different universe will be read
  !!   For invalid uniRootID any content may be returned
  !!
  elemental subroutine getFill(self, idx, id, uniRootID, localID)
    class(geomGraph), intent(in) :: self
    integer(shortInt), intent(out) :: idx
    integer(shortInt), intent(out) :: id
    integer(shortInt), intent(in)  :: uniRootId
    integer(shortInt), intent(in)  :: localID

    ! Set values
    idx = self % array(uniRootId + localID -1) % idx
    id = self % array(uniRootId + localID -1) % id

  end subroutine getFill

  !!
  !! Return to uninitialised state
  !!
  elemental subroutine kill(self)
    class(geomGraph), intent(inout) :: self

    if(allocated(self % array)) deallocate(self % array)
    if(allocated(self % usedMats)) deallocate(self % usedMats)
    if(allocated(self % uniSizes)) deallocate(self % uniSizes)
    self % rootUniIdx = 0
    self % uniqueCells = 0

  end subroutine kill


  !!
  !! Build a shrunk representation
  !!
  !! Shrunk representation assigns unique ID to every material local cell in each universe
  !! but does not distinguish between instances of the same universe (e.g. all pins in a lattice
  !! are considered the same pin from the point of view of unique ID)
  !!
  !! Args:
  !!   fills [in] -> Universe fill information. Must be valid as defined in `init` procedure.
  !!
  subroutine buildShrunk(self, fills)
    class(geomGraph), intent(inout)              :: self
    type(uniFills), intent(in)                   :: fills
    integer(shortInt)                            :: i, N, top, loc, fill, rootID
    integer(shortInt), dimension(:), allocatable :: unused
    type(intMap)                                 :: layed
    integer(shortInt), parameter :: NOT_FOUND = -7
    character(100), parameter    :: Here = 'buildShrunk (geomGraph_class.f90)'

    ! Get unused universes
    unused = fills % unusedUniverses()

    ! Allocate required space
    ! Is the number of local cells in all used universes
    N = 0
    do i = 1, size(fills % uni)
      if (.not.isIn(unused, fills % uni(i) % id)) then ! Is a used universe
        N = N + size(fills % uni(i) % fill)
      end if
    end do
    allocate (self % array(N))

    ! Lay out universes -> start with root
    ! `layed` stores layout universes as a map of idx -> location
    top = 1
    loc = 1
    call layed % add(fills % root, top)
    call layoutUniverse(self % array, top, fills, fills % root)

    ! Layout rest of the universes
    do while (loc <= size(self % array))
      ! Read content
      fill = self % array(loc) % idx

      ! Set uniRoot ID and layout if is universe
      if (fill < 0) then
        rootID = layed % getOrDefault(abs(fill), NOT_FOUND)
        if (rootID == NOT_FOUND) then ! Layout the universe
          rootID = top
          call layed % add(abs(fill), top)
          call layoutUniverse(self % array, top, fills, abs(fill))

        end if
        ! Store uniRootID
        self % array(loc) % id = rootID
      end if

      ! Increment location
      loc = loc + 1
    end do

    ! Check that top was reached
    if (top /= N + 1) then
      call fatalError(Here, 'Did not reach the end of the location array. Top is: '//&
                             numToChar(top)//' but should be: '//numToChar(N+1))
    end if

    ! Set unique IDs -> Enumerate sinks
    call self % setUniqueIDs()

  end subroutine buildShrunk

  !!
  !! Build a extended representation
  !!
  !! Extended representation changes the directed acyclic graph into a tree. Thus, local material
  !! cells in each instance of a universe have different uniqueID assigned.
  !!
  !! Args:
  !!   fills [in] -> Universe fill information. Must be valid as defined in `init` procedure.
  !!
  subroutine buildExtended(self, fills)
    class(geomGraph), intent(inout)  :: self
    type(uniFills), intent(in)       :: fills
    type(intMap)                     :: count
    integer(shortInt)                :: i, N, top, loc, fill, rootID
    character(100), parameter :: Here = 'buildExtended (geomGraph_class.f90)'

    ! Calculate required space
    ! Loop over all universes and calculate space required for all their instances
    call fills % countInstances(count)
    N = 0
    do i = 1, size(fills % uni)
      N = N + size(fills % uni(i) % fill) * count % get(i)
    end do

    ! Allocate required space
    allocate(self % array(N))

    ! Layout universes starting with root
    top = 1
    loc = 1
    call layoutUniverse(self % array, top, fills, fills % root)

    ! Layout rest of universes by going down the tree
    do while (loc <= size(self % array))
      ! Read content
      fill = self % array(loc) % idx

      ! Set uniRoot ID and layout if is universe
      if (fill < 0) then
        rootID = top
        call layoutUniverse(self % array, top, fills, abs(fill))

        ! Store uniRootID
        self % array(loc) % id = rootID

      end if

      ! Increment location
      loc = loc + 1
    end do

    ! Check that top was reached
    if (top /= N + 1) then
      call fatalError(Here, 'Did not reach the end of the location array. Top is: '//&
                             numToChar(top)//' but should be: '//numToChar(N+1))
    end if

    ! Set unique IDs -> Enumerate sinks
    call self % setUniqueIDs()

  end subroutine buildExtended

  !!
  !! Loop through `array` to enumerate sinks of the graph (setting unique ID)
  !!
  !! Also set:
  !!   * Number of unique IDs
  !!   * List of matIdx used in the geometry
  !!
  !! Args:
  !!   None
  !!
  !! Errors:
  !!   Assumes `array` is allocated. Will likely segment if it isn't.
  !!
  subroutine setUniqueIDs(self)
    class(geomGraph), intent(inout) :: self
    integer(shortInt)               :: i, cells, fill, pos
    type(intMap)                    :: matSet

    ! Loop over array
    cells = 0
    do i = 1, size(self % array)
      fill = self % array(i) % idx

      if (fill > 0) then ! It is material filling
        cells = cells + 1
        self % array(i) % id = cells
        call matSet % add(fill, 1)

      end if
    end do

    ! Set number of unique cells
    self % uniqueCells = cells

    ! Set used materials
    allocate (self % usedMats( matSet % length()))

    pos = 1
    i = matSet % begin()
    do while (i /= matSet % end())
      self % usedMats(pos) = matSet % atKey(i)
      pos = pos + 1
      i = matSet % next(i)

    end do

    ! Sort used materials
    call quickSort(self % usedMats)

  end subroutine setUniqueIDs

  !!
  !! Put universe data on the array
  !!
  !! Used by different build procedures
  !!
  !! Does not set uniRootID or uniqueID !
  !!
  !! Args:
  !!   array [inout]   -> Array of locations for universe data
  !!   freeLoc [inout] -> Index of the free first free location on the array. On exit set to the
  !!     new first free location.
  !!   fills [in]      -> Universe fill information
  !!   idx [in]     -> Index of the universe to lay out
  !!
  !! Errors:
  !!   fatalError if there is not enough data in the array
  !!
  subroutine layoutUniverse(array, freeLoc, fills, idx)
    type(location), dimension(:), intent(inout) :: array
    integer(shortInt), intent(inout)            :: freeLoc
    type(uniFills), intent(in)                  :: fills
    integer(shortInt), intent(in)               :: idx
    integer(shortInt)                           :: N
    character(100), parameter :: Here = 'layoutUniverse (geomGraph_class.f90)'

    ! Check universe idx
    if ( idx < 1 .or. idx > size(fills % uni)) then
      call fatalError(Here, 'Universe index: '//numToChar(idx)//' is invalid. Must be between &
                            &1 and '//numToChar(size(fills % uni)) )
    end if

    ! Check available space
    N = size(fills % uni(idx) % fill)
    if ( freeLoc + N-1 > size(array)) then
      call fatalError(Here, 'Overflow of the location array when laying out universe &
                           &(idx): '//numToChar(idx))
    end if

    ! Layout data
    array(freeLoc: freeLoc + N -1) % idx = fills % uni(idx) % fill
    freeLoc = freeLoc + N

  end subroutine layoutUniverse

  !!
  !! Create a list of materials to the maximum nesting level where they are present
  !!
  !! Args:
  !!   list [out] -> List of materials to the maximum nesting level where they are present
  !!
  subroutine materialNesting(self, list)
    class(geomGraph), intent(in) :: self
    type(intMap), intent(out)    :: list

    call materialNestingStep(self, list, 1, 1, self % uniSizes(self % rootUniIdx))

  end subroutine materialNesting


  !!
  !! Depth first search of the graph to find the maximum nesting level of each material
  !!
  !! Args:
  !!   list [inout] ->  Current list of maximum nesting for each material
  !!   depth [in] -> Current depth in the graph
  !!   uniRoot [in] -> Location of the universe in the array
  !!   uniLen [in] -> Number of local cells in the universe
  !!
  recursive subroutine materialNestingStep(self, list, depth, uniRoot, uniLen)
    class(geomGraph), intent(in)   :: self
    type(intMap), intent(inout)    :: list
    integer(shortInt), intent(in)  :: depth
    integer(shortInt), intent(in)  :: uniRoot
    integer(shortInt), intent(in)  :: uniLen
    integer(shortInt)              :: i, fill, id, mat_depth

    ! Loop over the local cells in the universe
    ! Next universe begins when idx is -ve
    do i = 1, uniLen
      fill = self % array(uniRoot + i -1) % idx
      id = self % array(uniRoot + i -1) % id

      if (fill < 0) then ! It is a universe
        call materialNestingStep(self, list, depth + 1, id, self % uniSizes(abs(fill)))
      else ! It is a material
        mat_depth = list % getOrDefault(fill, 0)
        call list % add(fill, max(mat_depth, depth))

      end if
    end do

  end subroutine materialNestingStep


end module geomGraph_class
